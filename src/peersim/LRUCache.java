package peersim;

import java.math.BigInteger;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

/**
 * @author Nawras Nazar
 * 
 * originally from {@link https://www.geeksforgeeks.org/design-a-data-structure-for-lru-cache/}
 */
public class LRUCache { 
    private LinkedHashMap<BigInteger, Object> map; 
    private final int CAPACITY; 
    public LRUCache(int capacity) 
    { 
        CAPACITY = capacity; 
        map = new LinkedHashMap<BigInteger, Object>(capacity, 0.75f, true) {
            /**
			 * auto-generated by IDE
			 */
			private static final long serialVersionUID = -348671614405439980L;
			// removeEldestEntry() is overridden to impose a policy for removing old mappings when size goes beyond capacity.
			protected boolean removeEldestEntry(Map.Entry eldest) 
            {
                return size() > CAPACITY; 
            } 
        }; 
    } 
  
    // This method works in O(1) 
    public Object get(BigInteger key) 
    { 
        // System.out.println("Going to get the value " + "for the key : " + key); 
        // return map.getOrDefault(key, -1);
        return map.get(key);
        
    } 
  
    // This method works in O(1) 
    public void set(BigInteger key, Object value) 
    { 
        // System.out.println("Going to set the (key, " + "value) : (" + key + ", " + value + ")"); 
        map.put(key, value); 
    } 
    
    /**
     * membership check; a way to use containsKey of private Map 
     * @param key
     * @return
     */
    public boolean member(BigInteger key) {
    	return this.map.containsKey(key);
    }
    
    /**
     * return the set of keys in the private Map
     * @return
     */
    public Set<BigInteger> allKeys() {
    	return this.map.keySet();
    }
    
    /**
     * return the number of kv in the map
     * @return
     */
    public int getSize() {
    	return this.map.size();
    }
    
    public static void main(String[] args) 
    { 
        
        HashMap<Integer, Integer> cache2 = new HashMap<>(2);
        cache2.put(1, 101);
        cache2.put(2, 102);
        cache2.put(3, 103);
        cache2.put(4, 104);
        cache2.put(5, 105);
        cache2.put(6, 106);
        cache2.put(7, 107);
        cache2.put(8, 108);
        cache2.put(9, 109);
        cache2.put(10, 110);
        cache2.put(11, 120);
        cache2.put(12, 120);
        cache2.put(13, 120);
        System.out.println(cache2);
        cache2.put(14, 130);
        System.out.println(cache2);
        
        System.out.println("Going to test the LRU Cache Implementation"); 
        LRUCache cache = new LRUCache(7);  
        cache.set(new BigInteger("10"), 10);  
        cache.set(new BigInteger("11"), 10);  
        cache.set(new BigInteger("12"), 10);  
        cache.set(new BigInteger("13"), 10);  
        cache.set(new BigInteger("14"), 10);  
        cache.set(new BigInteger("15"), 10);  
  
        // it will store a key (1) with value 10 in the cache. 
        cache.set(new BigInteger("2"), 20);  
        System.out.println("Value for the key: 1 is " +  
                           cache.get(new BigInteger("1"))); // returns 10 
  
        // evicts key 2 and store a key (3) with 
        // value 30 in the cache. 
        cache.set(new BigInteger("3"), 30);  
  
        System.out.println("Value for the key: 2 is " +  
                cache.get(new BigInteger("2"))); // returns -1 (not found) 
  
        // evicts key 1 and store a key (4) with 
        // value 40 in the cache. 
        cache.set(new BigInteger("4"), 40);  
        System.out.println("Value for the key: 1 is " + 
               cache.get(new BigInteger("1"))); // returns -1 (not found) 
        System.out.println("Value for the key: 3 is " +  
                           cache.get(new BigInteger("3"))); // returns 30 
        System.out.println("Value for the key: 4 is " + 
                           cache.get(new BigInteger("4"))); // return 40 
  
    } 
} 